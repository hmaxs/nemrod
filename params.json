{"name":"Nemrod","tagline":"","body":"Nemrod\r\n======\r\n\r\nWhat is Nemrod?\r\n-----------------\r\nNemrod is a framework providing an abstraction layer for handling (consuming and producing) RDF in a Symfony2 project,\r\nin the same way Symfony users are using Doctrine. The framework provides five main components:\r\n\r\n- a resource manager (similar to Doctrine's resource manager)\r\n- a SPARQL query builder allowing to interact directly with your sparql endpoint(s)\r\n- a form extension allowing to build forms to create or update data\r\n- a json-ld serializer allowing to produce framed json-ld representation of RDF\r\n- Optionally, a set of services can be set up that populates and update an Elasticsearch server wrt triple store content.\r\n\r\nNemrod mainly relies on\r\n\r\n- [EasyRdf](https://github.com/njh/easyrdf)\r\n- [Json-ld](https://github.com/lanthaler/JsonLD)\r\n- [Elastica](https://github.com/ruflin/Elastica)\r\n- [jms/serializer-bundle](https://github.com/schmittjoh/JMSSerializerBundle)\r\n\r\n\r\n\r\nRequirements\r\n------------\r\n- Symfony > 2.3, [Begin a Symfony Project](http://symfony.com/get-started)\r\n\r\nInstallation\r\n------------\r\nNemrod can be installed using composer. You first need to set the minimum stability level to \"dev\" in your composer.json:\r\n\r\n    {\r\n        ...\r\n        \"minimum-stability\": \"dev\"\r\n        ...\r\n    }\r\n\r\nyou can then install the framework using the command:\r\n\r\n    composer require conjecto/nemrod\r\n\r\nyou can also add dependency directly in your composer.json file:\r\n\r\n    \"conjecto/nemrod\": \"~0.1.0@dev\"\r\n\r\nThen you need to add one (or two) bundle(s) to the AppKernel.php:\r\n\r\n\tclass AppKernel extends Kernel\r\n\t{\r\n    \tpublic function registerBundles()\r\n    \t{\r\n        \t$bundles = array(\r\n\t\t\t    ...\r\n\t\t\t    new Conjecto\\Nemrod\\Bundle\\NemrodBundle\\NemrodBundle(),\r\n    \t\t    new Conjecto\\Nemrod\\Bundle\\ElasticaBundle\\ElasticaBundle(),\r\n\t\t\t    ...\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\nThe first bundle is the main framework bundle, the second should be enabled only if you wish to use an ElasticSearch server.\r\n\r\nA little bit of configuration is necessary to let Nemrod know one thing or two about your environment:\r\n\r\n\tnemrod:\r\n\t  endpoints:\r\n        my_endpoint: \"http://www.foo.org/sparql\"\r\n    \tanother_endpoint: \"http://www.bar.net/sparql\"\r\n      default_endpoint: my_endpoint\r\n      namespaces:\r\n        rdfs: \"http://www.w3.org/2000/01/rdf-schema#\"\r\n        foaf: \"http://xmlns.com/foaf/0.1/\"\r\n        #add the namespaces you need\r\n\t\tmycompany: \"http://www.example.org/mycompany\"\r\n\r\nAt this point, Nemrod knows enough to access to your data. Use the 'rm' service's `findAll()` (which is an alias for 'nemrod.resource\\_manager.my\\_endpoint'):\r\n\r\n\t<?php\r\n\t\r\n\tuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\r\n\tuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Template;\r\n\r\n\tclass ProductsController extends Controller\r\n\t{\r\n    \t/**\r\n     \t * @Route(\"/all/\", name=\"product.index\")\r\n     \t * @Template(\"ProductsBundle:index.html.twig\")\r\n     \t */\r\n    \tpublic function indexAction()\r\n    \t{\r\n\t\t\t$products = $this->container->get('rm')->getRepository('mycompany:Product')->findAll();\r\n\t\t\t...\r\n\t\t\treturn array(\"products\" => $products);\r\n\t\t}\r\n\t}\r\n\r\nAlternatively, you can refine the set of data you want to get using the `findBy()` method:\r\n\r\n    \t/**\r\n     \t * @Route(\"/category/{category}\", name=\"product.category\")\r\n     \t * @Template(\"ProductsBundle:index.html.twig\")\r\n     \t */\r\n    \tpublic function categoryAction($category)\r\n    \t{\r\n\t\t\t$products = $this->container->get('rm')\r\n\t\t\t\t->getRepository('mycompany:Product')\r\n\t\t\t\t->findBy(array('mycompany:category' => $category));\r\n\t\t\t...\r\n\t\t\treturn array(\"products\" => $products);\r\n\t\t}\r\n\r\nYou can then display your data using twig:\r\n\r\n\t<ul>\r\n    \t{% for product in products %}\r\n        \t<li class=\"list-group-item\">{{ product['rdfs:label'].value }}</li>\r\n      \t{% endfor %}\r\n    </ul>\r\n\r\nAnother possibility is to ask for a specific resource using its uri:\r\n\r\n    \t/**\r\n     \t * @Route(\"/view/{uri}\", name=\"product.view\")\r\n     \t * @Template(\"ProductsBundle:view.html.twig\")\r\n     \t */\r\n    \tpublic function viewAction($uri)\r\n    \t{\r\n\t\t\t$product = $this->container->get('rm')\r\n\t\t\t\t->getRepository('mycompany:Product')\r\n\t\t\t\t->find($uri);\r\n\t\t\t...\r\n\t\t\treturn array(\"product\" => $product);\r\n\t\t}\r\n\r\n\r\nIf you need to encapsulate specific logic over your data, you can overload the default resource abstraction class. Overloading class must be defined in a RdfResource directory of your bundle directory:\r\n\r\n\r\n\t+-- ProductBundle\r\n\t|   +-- Controller\r\n\t|   +-- DependencyInjection\r\n\t|   +-- Resources\r\n\t|   +-- RdfResource\r\n\t|\t\t+-- Product\r\n\r\nand must extend `Conjecto\\Nemrod\\Resource` (which is the default abstraction class):\r\n\t\r\n\t<?php\r\n\t\r\n\tnamespace MyCompany\\ProductBundle\\RdfResource;\r\n\t\r\n\tuse Conjecto\\Nemrod\\Resource as BaseResource;\r\n\tuse Conjecto\\Nemrod\\ResourceManager\\Annotation\\Resource;\r\n\t\r\n\t/**\r\n\t * Class Product\r\n\t * @Resource(types={\"mycompany:Product\"}, uriPattern = \"mycompany:product:\")\r\n\t */\r\n\tclass Product extends BaseResource\r\n\t{\r\n\r\n\t}\r\n\r\nthe @Resource annotation allows to map your class and RDF types, so you can get an instance of this class when asking for object with the given types:\r\n\r\n\t$product = $this->container->get('rm')->getRepository('mycompany:Product')->find($uri);\r\n\r\nwill fill `$products` with an array of `MyCompany\\ProductBundle\\RdfResource\\Product` objects.\r\n\r\nAn URI pattern can also be provided with `uriPattern`. It will be used to set an URI for a new resource. For now, the specified pattern is just used as a prefix\r\n\r\nDocumentation\r\n-------------\r\n\r\n- [Using the Query Builder](doc/querybuilder.md)\r\n- [Creating forms](doc/forms.md)\r\n- [Serializing resources to Json-ld](doc/serializer.md)\r\n- [Using ElasticSearch to index your data](doc/elasticsearch.md)\r\n\r\nContributing\r\n------------\r\n\r\n- Feel free to install and test the framework. We'd love to have some feedback about it.\r\n- A lot of tests has to be written. We are currently putting effort on that point. Any help would be appreciated.\r\n\r\n\r\nLicensing\r\n-----\r\nThe Nemrod framework is licensed under the [BSD-3-Clause](LICENSE.md) license.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}